# fork()函数

fork()函数是从一个已存在的进程中创建一个新进程;新进程为子进程，而原进程称为父进程。以当前进程作为父进程创建出一个新的子进程，并且将父进程的所有资源拷贝给子进程，这样子进程作为父进程的一个副本存在。父子进程几乎完全相同的，但进程ID不同。 

   #include "sys/types.h"
   #include "unistd.h"
   #include pit_t fork(void );

> fork()函数调用成功，返回两个值；
>
> * 在父进程中：fork返回新创建子进程的进程ID
> * 在子进程中：返回0；
>
>    fork()函数调用出错：
>
> * 返回-1；

        一个进程主要包括以下几个方面的内容:
　　(1)一个可以执行的程序
　　(2) 与进程相关联的全部数据(包括变量，内存，缓冲区)
　　(3)程序上下文(程序计数器PC,保存程序执行的位置) 

## fork 函数的底层实现原理

​	fork()系统调用通过复制一个现有进程来创建一个全新的进程。进程被存放在一个叫做任务队列的双向循环链表当中，链表当中的每一项都是类型为task_struct称为进程描述符的结构，也就是进程PCB.

​	内核通过一个位置的进程标识值或ID来标识每一个进程。 

当进程调用fork后，控制转移到内核中的fork代码后，内核会做4件事情: 
1、分配新的内存块和内核数据结构给子进程

2、将父进程部分数据结构内容拷贝,到子进程

3、添加子进程到系统进程列表当中

4、fork返回，开始调度器调度 

## **在这里有一个疑问，那么fork函数在底层到底做了什么呢？** 

Linux平台通过clone()系统调用实现fork()。 fork()，vfork()和clone()（克隆）库函数都根据各自需要的参数标志去调用clone()，然后由clone()去调用do_fork()， 再然后do_fork()完成了创建中的大部分工作，该函数调用copy_process().做最后的那部分工作。![1582450881499](/tmp/1582450881499.png)





## **那么fork函数为什么是一次调用，却返回了两次呢？**

​	当程序执行到下面的语句： pid=fork();
	由于在复制时复制了父进程的堆栈段，所以两个进程都停留在fork函数中，等待返回。因此fork函数会返回两次，一次是在父进程中返回，另一次是在子进程中返回，这两次的返回值是不一样的。 
fork函数有三种不同的返回值：

> 1）在父进程中，fork返回新创建子进程的进程ID； 
> 2）在子进程中，fork返回0； 
> 3）如果出现错误，fork返回-1。
>

​	我们可以通过fork返回的值来判断当前进程是子进程还是父进程。其实就相当于链表，进程形成了链表，父进程的fork函数返回的值指向子进程的进程id, 因为子进程没有子进程，所以其fork函数返回的值为0.

​	调用fork之后，数据、堆、栈有两份，代码仍然为一份但是这个代码段成为两个进程的共享代码段都从fork函数中返回。当父子进程有一个想要修改数据或者堆栈时，两个进程分裂。

​	而且我们还需要注意的是：子进程的代码是从fork处执行的，fork底层实现采用了COW（copy_on_write）技术—-写入时拷贝
	写时拷贝思想：父进程和子进程共享页帧而不是复制页帧。然而，只要页帧被共享，它们就不能被修改，即页帧被保护。无论父进程还是子进程何时试图写一个共享的页帧，就产生一个异常，这时内核就把这个页复制到一个新的页帧中并标记为可写。原来的页帧仍然是写保护的：当其他进程试图写入时，内核检查写进程是否是这个页帧的唯一属主，如果是，就把这个页帧标记为对这个进程是可写的。
