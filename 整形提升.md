# 整形提升 

下面程序的结果是多少？

```c
#include<stdio.h>
int main()
{   
	unsigned char a = 0xA5;
	unsigned char b = ~a>>4+1;
	printf("b = %d\n",b);
	return 0;
}

```

回答这个问题时，我们需要先了解什么整型提升？以及符号的优先级？

**整型提升**是C语言程序设计中的一项规定：在表达式计算时，各种整形首先要提升为int类型，如果int类型不足以表示就要提升为unsigned(无符号) int类型；然后执行表达式的运算。整型提升时如果是无符号数据则左边补0，如果是有符号数据就补符号位。

第二点，~的优先级最高，>>符的优先级最低。故先求反再求和，最后移位。

由上述两个知识点，我们可以开始分析。首先变量a整型提升的0x000000A5.取反之后得0xFFFFFF5A。再求和4+1=5。最后将0xFFFFFF5A左移5位。得到0x07FFFFFA。因为b是char类型，故取一个字节。b = 0xFA = 250。所以例题输出250。

如果将上述无符号改为有符号。那么结果也会不同。同学们可以计算一下结果，加深理解。

#  数据交换

例：有两个数据，写出交换数据的宏。

我们按照通常是这样写的：

```c
#define  swap(a,b) 
{  
    a = a + b;
    b = a - b;
    a = a - b;
}

```

这样写的缺点是不能避免数据的溢出，如果a+b的结果大于a所能表示的最大值。那么结果就会发生错误。

稍微高级一点的，会用按位异或运算。

```c
#define swap(a,b)
{ 
   a = a ^ b;
   b = a ^ b;
   a = a ^ b;
}

```

用异或运算可以很好地避免数据溢出的问题。但是它对于float类型的数据是不适用。但是该题没有限制数据的类型。所以我们应该用内存交换。

```c
#define swap（）
{ 
    char tempBuf[10];
    memcpy(tempBuf,&a,sizeof(a));
    memcpy(&a,&b,sizeof(b));
    memcpy(&b,tempBuf,sizeof(b));
}

```

这样就可以适用任何的数据类型了。